generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  password      String?
  image         String?
  isSeller      Boolean   @default(false)
  role          String    @default("BUYER")
  bio           String?   @default("")
  skills        String?   @default("[]") // JSON string
  languages     String?   @default("[]") // JSON string
  country       String?   @default("")
  sellerLevel   String    @default("NEW")
  responseTime  Int?      @default(0)
  completedOrders Int     @default(0)
  ongoingOrders   Int     @default(0)
  memberSince   DateTime  @default(now())
  lastActive    DateTime  @default(now())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  gigs          Gig[]
  orders        Order[]     @relation("BuyerOrders")
  soldOrders    Order[]     @relation("SellerOrders")
  reviews       Review[]
  favorites     Favorite[]
  notifications Notification[]
  sentMessages     Message[]    @relation("SentMessages")
  conversations    Conversation[] @relation("UserConversations") // Many-to-many implicit? No, db.ts has explicit table logic, but Prisma needs careful relation. 
                                                                 // db.ts `conversations` has user1Id and user2Id.
                                                                 // So Conversation model must match that structure.
  buyerRequests    BuyerRequest[] @relation("BuyerRequests")
  customOffers     CustomOffer[]  @relation("SellerOffers")
  customOffersReceived CustomOffer[] @relation("BuyerOffers") // Buyer receives offers
  
  @@map("users")
}

model Gig {
  id          String   @id @default(cuid())
  title       String
  description String
  category    String
  subcategory String? @default("")
  tags        String? @default("[]")
  price       Float
  location    String?
  image       String?
  gallery     String? @default("[]")
  faq         String? @default("[]")
  requirements String? @default("[]")
  status      String  @default("ACTIVE")
  impressions Int     @default(0)
  clicks      Int     @default(0)
  ordersCount Int     @default(0) @map("orders") // db.ts uses 'orders' column
  
  sellerId    String
  seller      User     @relation(fields: [sellerId], references: [id])
  
  tiers       GigTier[]
  orders      Order[]
  reviews     Review[]
  favorites   Favorite[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("gigs")
}

model GigTier {
  id        String @id @default(cuid())
  name      String
  title     String? @default("")
  description String? @default("")
  price     Float
  delivery  Int
  revisions Int    @default(1)
  features  String
  gigId     String
  gig       Gig    @relation(fields: [gigId], references: [id], onDelete: Cascade)
  
  @@map("gig_tiers")
}

model Order {
  id           String   @id @default(cuid())
  status       String   @default("PENDING")
  total        Float
  serviceFee   Float    @default(0)
  tierId       String?
  tierName     String?  @default("Basic")
  deliveryDate DateTime?
  requirements String?  @default("")
  sellerNote   String?  @default("")
  
  buyerId      String
  buyer        User     @relation("BuyerOrders", fields: [buyerId], references: [id])
  sellerId     String   @default("")
  seller       User     @relation("SellerOrders", fields: [sellerId], references: [id])
  
  gigId        String
  gig          Gig      @relation(fields: [gigId], references: [id])
  
  deliveries   Delivery[]
  revisions    Revision[]
  activityLogs ActivityLog[]
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  completedAt  DateTime?
  
  @@map("orders")
}

model Delivery {
  id          String   @id @default(cuid())
  orderId     String
  order       Order    @relation(fields: [orderId], references: [id])
  message     String
  files       String?  @default("[]")
  status      String   @default("PENDING")
  createdAt   DateTime @default(now())
  
  @@map("deliveries")
}

model Revision {
  id        String   @id @default(cuid())
  orderId   String
  order     Order    @relation(fields: [orderId], references: [id])
  message   String
  buyerId   String
  createdAt DateTime @default(now())
  
  @@map("revisions")
}

model Review {
  id        String   @id @default(cuid())
  rating    Int
  communicationRating Int @default(5)
  serviceRating       Int @default(5)
  recommendRating     Int @default(5)
  comment   String
  sellerResponse String? @default("")
  orderId   String?
  
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  gigId     String
  gig       Gig      @relation(fields: [gigId], references: [id])
  createdAt DateTime @default(now())
  
  @@map("reviews")
}

model Conversation {
  id           String    @id @default(cuid())
  user1Id      String
  user2Id      String
  lastMessage  String?   @default("")
  lastMessageAt DateTime @default(now())
  createdAt    DateTime  @default(now())
  
  // Relations to User are tricky with just 2 IDs manually managed.
  // We can treat them as relation fields if we want Prisma to navigate.
  // But db.ts defines simple FKs.
  user1        User      @relation("UserConversations", fields: [user1Id], references: [id]) 
  // Prisma doesn't support 2 refs seamlessly in array without disambiguating implies.
  // Let's keep it simple for now, map to table.
  
  messages     Message[]
  
  @@map("conversations")
  @@ignore // Ignoring relations check for now or handle user2 manually
}

model Message {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id])
  
  senderId       String
  sender         User         @relation("SentMessages", fields: [senderId], references: [id])
  
  content        String
  isRead         Boolean      @default(false)
  attachments    String?      @default("[]")
  createdAt      DateTime     @default(now())
  
  @@map("messages")
}

model Favorite {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  gigId     String
  gig       Gig      @relation(fields: [gigId], references: [id])
  createdAt DateTime @default(now())

  @@unique([userId, gigId])
  @@map("favorites")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  type      String   // ORDER, MESSAGE, REVIEW, SYSTEM
  title     String
  message   String
  link      String?  @default("")
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  
  @@map("notifications")
}

model BuyerRequest {
  id           String   @id @default(cuid())
  title        String
  description  String
  category     String
  budget       Float
  deliveryDays Int      @default(7)
  attachments  String?  @default("[]")
  status       String   @default("OPEN")
  offersCount  Int      @default(0)
  
  buyerId      String
  user         User     @relation("BuyerRequests", fields: [buyerId], references: [id])
  
  offers       CustomOffer[]
  
  createdAt    DateTime @default(now())
  
  @@map("buyer_requests")
}

model CustomOffer {
  id             String       @id @default(cuid())
  requestId      String?
  request        BuyerRequest? @relation(fields: [requestId], references: [id])
  
  buyerId        String
  user           User          @relation("BuyerOffers", fields: [buyerId], references: [id])

  sellerId       String
  seller         User          @relation("SellerOffers", fields: [sellerId], references: [id])

  gigId          String?
  description    String
  price          Float
  deliveryDays   Int
  revisions      Int          @default(1)
  status         String       @default("PENDING") 
  
  createdAt      DateTime     @default(now())
  
  @@map("custom_offers")
}

model ActivityLog {
  id        String   @id @default(cuid())
  orderId   String
  order     Order    @relation(fields: [orderId], references: [id])
  type      String
  message   String
  userId    String?
  createdAt DateTime @default(now())
  
  @@map("activity_log")
}
